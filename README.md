markdown
# Проект по фильтрации и сортировке данных

## Описание проекта

Данный проект представляет собой скрипт на Python, который реализует функции для фильтрации и сортировки списка словарей, содержащих информацию о различных элементах, а также функции для работы с банковскими транзакциями. Основные цели проекта:

- Фильтрация данных по ключу `state`.
- Сортировка данных по ключу `date` в формате ISO.
- Фильтрация транзакций по валюте.
- Получение описаний транзакций.
- Генерация номеров банковских карт.

Этот проект может быть полезен при работе с коллекциями данных, где необходимо быстро получать нужные элементы, сортировать их и работать с финансами.

## Установка

Для работы проекта необходимы следующие пакеты:

- json - встроенная библиотека Python.
- logging - встроенная библиотека Python.
- unittest - встроенная библиотека для тестирования.

1. Установить [Python](https://www.python.org/downloads/) (рекомендуется версия 3.6 и выше).
2. Клонировать репозиторий на локальный компьютер:
```
git clone git@github.com:ваш_пользователь/название_репозитория.git
```
3. Установите необходимые зависимости:
```
pip install -r requirements
```
4. Создайте файл *.env* в корневом каталоге проекта и добавьте ваш *API* ключ:
```commandline
EXCHANGE_API_KEY=ваш_ключ_api
```
5. Перейдите в директорию проекта

## Использование

### Импорт функций

```
from your_module_name import filter_by_state, sort_by_date, filter_by_currency, transaction_descriptions, card_number_generator
```
### Функции

#### 1. `filter_by_state(data: List[Dict[str, Any]], state: str = "EXECUTED") -> List[Dict[str, Any]]`

**Описание:** Фильтрует список словарей по значению ключа `state`.

**Параметры:**

- `data` (List[Dict[str, Any]]): Список словарей, который нужно фильтровать.
- `state` (str): Значение ключа `state` для фильтрации. По умолчанию `'EXECUTED'`.

**Возвращает:** Новый список словарей, содержащих только те, у которых ключ `state` соответствует заданному значению.

**Пример:**

data = [
{"id": 41428829, "state": "EXECUTED", "date": "2019-07-03T18:35:29.512364"},
{"id": 939719570, "state": "EXECUTED", "date": "2018-06-30T02:08:58.425572"},
{"id": 594226727, "state": "CANCELED", "date": "2018-09-12T21:27:25.241689"},
{"id": 615064591, "state": "CANCELED", "date": "2018-10-14T08:21:33.419441"},
]

executed_items = filter_by_state(data)
print(executed_items)

# Вывод: [{'id': 41428829, 'state': 'EXECUTED', 'date': '2019-07-03T18:35:29.512364'}, {'id': 939719570, 'state': 'EXECUTED', 'date': '2018-06-30T02:08:58.425572'}]

#### 2. `sort_by_date(data: List[Dict[str, Any]], reverse: bool = True) -> List[Dict[str, Any]]`

**Описание:** Сортирует список словарей по дате.

**Параметры:**

- `data` (List[Dict[str, Any]]): Список словарей, который нужно сортировать.
- `reverse` (bool): Параметр для определения порядка сортировки. По умолчанию `True` (убывание). Если `False`, то сортировка в порядке возрастания.

**Возвращает:** Новый список словарей, отсортированный по дате.

**Пример:**

sorted_executed_items = sort_by_date(executed_items)
print(sorted_executed_items)

# Вывод: [{'id': 41428829, 'state': 'EXECUTED', 'date': '2019-07-03T18:35:29.512364'}, {'id': 939719570, 'state': 'EXECUTED', 'date': '2018-06-30T02:08:58.425572'}]

#### 3. `filter_by_currency(transactions: List[Dict], currency: str) -> Generator[Union[Dict, str], None, None]`

**Описание:** Эта функция возвращает итератор, который поочередно выдает транзакции, где валюта операции соответствует заданной. Если транзакции не найдены, возвращает строку "Нет значений".

**Параметры:**
- `transactions`: список словарей с транзакциями.
- `currency`: строка, представляющая нужную валюту.

**Возвращает:** генератор, который выдает либо словарь с транзакцией, либо строку.

**Пример:**

usd_transactions = filter_by_currency(transactions, "USD")
for transaction in usd_transactions:
print(transaction)

#### 4. `transaction_descriptions(transactions: List[Dict]) -> Generator[str, None, None]`

**Описание:** Эта функция принимает список словарей с транзакциями и возвращает описание каждой операции по очереди. Если описание отсутствует, возвращает "Описание отсутствует".

**Параметры:**
- `transactions`: список словарей с транзакциями.

**Возвращает:** генератор строк, содержащих описания транзакций.

**Пример:**

descriptions = transaction_descriptions(transactions)
for description in descriptions:
print(description)

#### 5. `card_number_generator(start: int, stop: int) -> Generator[str, None, None]`

**Описание:** Генератор, который выдает номера банковских карт в формате: `XXXX XXXX XXXX XXXX`. Номера генерируются на основе заданного диапазона.

**Параметры:**
- `start`: начальное значение диапазона (включительно).
- `stop`: конечное значение диапазона (включительно).

**Возвращает:** генератор строк, представляющих номера карт.

**Пример:**

for card_number in card_number_generator(1, 5):
print(card_number)

#### 6. `def load_transactions`

**Описание:** Функция *load_transactions* принимает путь к JSON-файлу и возвращает список валидных транзакций. Загруженные данные должны быть в формате списка словарей. Функция выполняет следующие проверки:
- Существует ли указанный файл.
- Не повреждён ли файл и правильно ли он отформатирован в JSON.
- Являются ли загруженные данные списком и содержат ли требуемые поля.

Логирование настроено для отслеживания процесса загрузки и обработки данных.

**Пример:**

1. Измените путь в переменной *path* в коде на путь к вашему JSON-файлу.
2. Запустите скрипт.

```commandline
if __name__ == "__main__":
transactions = load_transactions("data/operations.json")
print("Полученные транзакции:", transactions)
```

#### 7. `convert_to_rub`

**Описание:** Функция *convert_to_rub* включает в себя функциональность для конвертации валют в рубли (RUB) с использованием *API* для получения курсов валют. Проект написан на *Python* и включает тестирование для обеспечения надежности функций.

**Пример:**
```commandline
from src.external_api import convert_to_rub

rub = convert_to_rub(100, "USD")
print(f"Сумма в рублях: {rub}")
```

#### 8. `get_financial_transactions`

**Описание:** Функция *get_financial_transactions* предназначена для чтения финансовых транзакций из *CSV* файла и их обработки. Функция загружает транзакции, а также набор тестов для проверки правильности функционирования этой функции.

### Чтение транзакций из CSV

Чтобы использовать функцию *get_financial_transactions* для чтения данных из CSV-файла, выполните следующий код:
```commandline
from src.transactions_csv import get_financial_transactions
path = "transactions.csv"  # Путь к вашему CSV файлу 
transactions = get_financial_transactions(path)
print(transactions)
```
Функция *get_financial_transactions* принимает путь к CSV файлу в качестве аргумента и возвращает список транзакций в виде словарей. Каждая транзакция включает такие поля, как *id*, *state*, *date*, *amount*, *currency_name*, *currency_code*, *from*, *to* и *description*.

### Формат *CSV* файла

*CSV* файл должен следовать следующему формату, с разделителем ";" :
```commandline
id;state;date;amount;currency_name;currency_code;from;to;description
complete;2023-01-01;100;USD;USD;Alice;Bob;Payment
pending;2023-02-01;200;EUR;EUR;Alice;Charlie;Transfer
```
#### 9. `get_financial_transactions_operations`

**Описание:** Функция *get_financial_transactions_operations* предназначена для работы с финансовыми транзакциями, которые хранятся в файле Excel. Функция осуществляет чтение транзакционных данных и предоставляет их в виде списка словарей. Также предусмотрены тесты для проверки функциональности.

## Использование

Функция *get_financial_transactions_operations* выполняет следующие действия:

- Читает файл *Excel*, путь к которому передается в качестве аргумента.
- Извлекает данные из файла и преобразует каждую строку в словарь.
- Возвращает список словарей, где каждый словарь представляет собой транзакцию.

#### Параметры:

- path: строка, указывающая путь к файлу *Excel*.

#### Пример вызова:
*Не забудьте заменить *path* на свой путь, где находится ваш файл Excel*
```commandline
if __name__ == "__main__":
path = "C:/Users/zheba/AppData/Local/Programs/Python/Python312/homework_done_12_1/src/transactions_excel.xlsx"
operations = get_financial_transactions_operations(path)
print(operations)
```
#### 10. `filter_transactions(transactions, status)`

**Описание:** Функция *filter_transactions(transactions, status)* фильтрует список транзакций по заданному статусу.

Параметры:
- *transactions (list)*: Список транзакций, где каждая транзакция представлена как словарь.
- *status (str)*: Статус транзакции для фильтрации (например, *"EXECUTED", "CANCELED", "PENDING"*).

Возвращает:
- *(list)*: Список транзакций, соответствующих заданному статусу.

**Пример использования:**
```
transactions = [
{"id": 1, "description": "Покупка продуктов", "status": "EXECUTED"},
{"id": 2, "description": "Оплата коммунальных услуг", "status": "CANCELED"},
]

filtered = filter_transactions(transactions, "EXECUTED")
print(filtered) # [{'id': 1, 'description': 'Покупка продуктов', 'status': 'EXECUTED'}]
```
#### 11. `categorize_transactions(transactions, categories)`

Функция подсчитывает количество операций для каждой из заданных категорий.

Параметры:
- *transactions (list)*: Список транзакций, где каждая транзакция представлена как словарь.
- *categories (list)*: Список категорий для подсчета транзакций.<br><br><strong>Возвращает:
- *(dict)*: Словарь с категориями в качестве ключей и количеством транзакций в каждой категории в качестве значений.

Пример использования:

```commandline
transactions = [
{"id": 1, "description": "Покупка продуктов", "amount": 150},
{"id": 2, "description": "Оплата коммунальных услуг", "amount": 75},
]

categories = ["Покупка", "Оплата"]
result = categorize_transactions(transactions, categories)
print(result) # {'Покупка': 1, 'Оплата': 1}
```

### Декоратор логирования

Все события, происходящие во время выполнения скрипта, записываются в файл *logs.log*. В этом файле будут подробно описаны:

- Статусы загрузки.
- Ошибки и исключения, если они возникнут.

#### Как использовать декоратор

Чтобы использовать декоратор `log`, вам нужно импортировать его из модуля `src.decorators` и применить его к вашей функции. Вот пример:
```
from src.decorators import log

@log("test_log.txt")
def divide(x, y):
return x / y
```

#### Описание функциональности

- **Запись вызовов функций:** Декоратор будет записывать в указанный файл (`test_log.txt`) текстовую информацию о каждом вызове функции, включая имя функции, переданные ей аргументы и возвращаемое значение.
  
- **Обработка ошибок:** Если в функции возникает ошибка (например, деление на ноль), декоратор также запишет информацию об ошибке в файл, включая аргументы, с которыми произошла ошибка.

#### Примеры использования

##### Успешный вызов:

```
divide(10, 2)
```

*Запись в файл `test_log.txt`:*

Запуск функции: divide с аргументами: (10, 2), {}
Функция: divide вернула: 5.0

##### Ошибка:

divide(10, 0)


*Запись в файл `test_log.txt`:*


Запуск функции: divide с аргументами: (10, 0), {}
Ошибка в функции: divide с аргументами: (10, 0), {}


### Установка

(Опишите, как установить проект или необходимые зависимости, если это необходимо.)

### Запуск тестов

Для запуска тестов используется `pytest`. Запустите следующие команды в терминале:

```commandline
python -m unittest discover -s tests
```
Убедитесь, что тесты находятся в каталоге *tests*, а код находится в *src*

## Заключение

Этот проект предоставляет удобные функции для фильтрации и сортировки данных в формате словаря. Он может быть полезен в различных сценариях работы с данными, таких как анализ, обработка и представление информации.

Для предложений и вопросов, пожалуйста, свяжитесь с [ваша_электронная_почта]. 

## Лицензия

Этот проект лицензирован под [Вашей лицензией].

### Примечания:
- Замените `ваш_пользователь` и `название_репозитория` на ваши данные.
- Позаботьтесь о добавлении лицензии, если планируете делиться кодом публично.

# Тестирование

В этом проекте используются юнит-тесты для проверки корректности работы функций.

## Зависимости

Перед запуском тестов убедитесь, что у вас установлены необходимые зависимости. Для этого вам потребуется `pytest`. Установить его можно с помощью следующей команды:
```
pip install pytest
```

## Запуск тестов

1. Убедитесь, что вы находитесь в корневой директории проекта, где расположен файл, который вы хотите протестировать (или где находятся тестовые файлы).
2. Запустите тесты с помощью команды:
```
pytest
```
3. Для запуска тестов с дополнительной информацией и подробным выводом вы можете использовать флаг `-v` (verbose):
```
pytest -v
```
4. Если вы хотите запустить тесты только для конкретного файла, вы можете указать его после команды `pytest`:
```commandline
pytest tests/test_file.py
```
## Результаты тестов

После запуска тестов вы увидите вывод, который покажет, какие тесты прошли, а какие провалились. Если тесты не прошли, обратите внимание на сообщения об ошибках для устранения проблем.

### Примечания:
- Замените `tests/test_file.py` на имя вашего файла с тестами.
- Убедитесь, что ваша структура каталогов и названия файлов соответствуют тем, что вы указали в разделе тестирования.